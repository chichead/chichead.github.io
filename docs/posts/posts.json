[
  {
    "path": "posts/geofacet_package/",
    "title": "대선 득표율 지도 with R",
    "description": "geofacet package + ggplot package",
    "author": [
      {
        "name": "chichead",
        "url": {}
      }
    ],
    "date": "2022-03-20",
    "categories": [
      "Visualization"
    ],
    "contents": "\n\nContents\ngeo_grid를 활용한 시각화\n멋드러진 해외의 선거 시각화\ngeofacet package\n\ngeo_grid + ggplot\n선거 데이터 만들기\nlong form 으로 만들기\nggplot 그래프 그리기\n최종 시각화\n\n\ngeo_grid를 활용한 시각화\n멋드러진 해외의 선거 시각화\nNYT의 2020 미 대선 투표율 시각화FiveThirtyEight의 2020 미 대선 선거결과 시각화해외 언론에서 선거 결과를 시각화한 기사를 볼 때마다 드는 생각이 있습니다. “아 우리나라도 저렇게 격자형태로 시각화하면 멋드러지지 않을까…” 국내에서는 시군구 혹은 읍면동 단위로 색을 칠하는 형태가 대부분이지 그 안에 그래프를 넣어서 시각화하기가 힘들어요. 미국은 50개 주에 1개의 특별구로 이루어졌으니, 필요한 격자는 51개 뿐이지만 우리나라의 시군구는 250개. 큰 권역 구분 정도는 다양한 시각화를 시도할 수 있지만 시군구 단위로 하기엔 부담이 될 수 있는거죠.\ngeofacet package\n\n그래도 해보고 싶습니다. 우리나라도 시군구 단위로 멋드러지게 만들고 싶어요. 그래서(!) 시군구 단위 그리드 만들어 봤습니다. 활용한 패키지는 geofacet입니다. geofacet은 말 그대로 지리적 정보(geo)로 면(facet)을 분할해 볼 수 있는 패키지인데요, 이 패키지가 좋은 건 Grid Designer라는 기능을 통해 자기만의 그리드를 만들 수 있다는 거죠. 그래서 지도를 펼치고 250개 시군구의 위치를 하나하나 지정해가며 만들어 봤습니다. geofacet package에도 제출해 놓았습니다. 여기에서 확인할 수 있어요.\n\n# A tibble: 6 × 4\n  code    row   col name               \n  <chr> <dbl> <dbl> <chr>              \n1 11110     5     7 서울특별시 종로구  \n2 11140     6     7 서울특별시 중구    \n3 11170     7     7 서울특별시 용산구  \n4 11200     6     8 서울특별시 성동구  \n5 11215     7     8 서울특별시 광진구  \n6 11230     5     8 서울특별시 동대문구\n\n만들어 놓은 대한민국 시군구 단위 그리드 구조는 아주 간단합니다. 이름, row, col, code 정도로 이루어져 있죠. geofacet 함수는 그리드의 행(row)과 열(col)을 인식해서 그 모양에 맞춰 facet해 주는 구조입니다. 이 그리드를 가지고 그려보면 이런 모양이 나옵니다.\ngeofacet::grid_preview(mygrid)\n\n\n\n짜잔~ 면적이 서로 다른 시군구를 동일한 면적 단위로 표현했기때문에 실제 위치와는 차이가 있을 수 있습니다. 시군구 그리드에 적용된 코드는 행정안전부에서 제공하고 있는 행정표준코드를 따라서 만들어 놓았습니다. 종로구(11110), 중구(11140) 이런식으로 말이죠. 시군구 단위의 여러 데이터들을 합쳐서 시각화, 분석할 일 있으면 행정코드 기준으로 정리한다면 간단하게 할 수 있을 겁니다.\n\ngeo_grid + ggplot\n선거 데이터 만들기\n이제 여기에 해야할 것은 각각의 시군구에 그래프를 넣어보는 겁니다. 이번 대통령 선거 득표 정보를 바탕으로 그래프를 넣어보려고 해요. 선관위 개표 데이터를 정리해서 다음과 같은 데이터(PE_20)를 만들어 봤습니다. PE_20 데이터는 여기에서 다운받을 수 있습니다.\nhead(PE_20)\n\n# A tibble: 6 × 21\n   code 구분      시군구명 선거인수 투표수 이재명 윤석열 심상정 오준호\n  <dbl> <chr>     <chr>       <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1 11110 서울특별… 종로구     129968 100629  46130  49172   3115     53\n2 11140 서울특별… 중구       111448  84998  38244  42906   2310     46\n3 11170 서울특별… 용산구     199077 152068  60063  85047   4374     67\n4 11200 서울특별… 성동구     252087 197240  84411 103880   5365    123\n5 11215 서울특별… 광진구     303582 235471 109922 113733   7072    155\n6 11230 서울특별… 동대문구   300928 232106 108171 112890   6416    151\n# … with 12 more variables: 허경영 <dbl>, 이백윤 <dbl>, 옥은호 <dbl>,\n#   김경재 <dbl>, 조원진 <dbl>, 김재연 <dbl>, 이경희 <dbl>,\n#   김민찬 <dbl>, 계 <dbl>, 무효투표수 <dbl>, 기권수 <dbl>,\n#   개표율 <dbl>\n\nPE_20 데이터에는 각 시군구 단위로 후보별 득표수를 넣어 두었습니다. 시군구별 선거인수, 후보별 득표수, 무효투표수, 기권수 등… 이 데이터로 시각화를 바로 할 순 없습니다. 우리에게 필요한 건 각 후보별 득표율이니까, 조금 더 정제할 필요가 있죠. 일단 득표율 TOP3 후보의 득표율을 계산해보겠습니다. 득표율은 후보별 투표수를 전체 투표수 - 무효투표수로 나누면 됩니다.\nlibrary(dplyr)\n\nPE_20 <- PE_20 %>% mutate(이재명R = 이재명 / (투표수 - 무효투표수),\n                          윤석열R = 윤석열 / (투표수 - 무효투표수),\n                          심상정R = 심상정 / (투표수 - 무효투표수))\n\nPE_20_rate <- PE_20 %>% select(c(code, 이재명R, 윤석열R, 심상정R, 구분, 시군구명))\nhead(PE_20_rate)\n\n# A tibble: 6 × 6\n   code 이재명R 윤석열R 심상정R 구분       시군구명\n  <dbl>   <dbl>   <dbl>   <dbl> <chr>      <chr>   \n1 11110   0.464   0.495  0.0313 서울특별시 종로구  \n2 11140   0.454   0.510  0.0274 서울특별시 중구    \n3 11170   0.399   0.564  0.0290 서울특별시 용산구  \n4 11200   0.432   0.532  0.0275 서울특별시 성동구  \n5 11215   0.472   0.488  0.0304 서울특별시 광진구  \n6 11230   0.471   0.492  0.0279 서울특별시 동대문구\n\n제대로 계산되었는지 비교해봅시다. 선관위 홈페이지에서 살펴보면 종로구에서 3명의 후보의 득표율이 46.42%, 49.48%, 3.13%였고, 중구에서의 득표율이 각각 45.42%, 50.96%, 2.74% 군요. 계산된 것과 비교해보니 맞는것 같습니다. 계산된 데이터는 wide form인데 시각화를 위해선 long form으로 조정할 필요가 있어요.\nlong form 으로 만들기\nlong form으로 바꾸는 법은 여러가지가 있지만 여기선 2개를 소개해드리겠습니다. 먼저 tidyr 패키지의 gather 함수. gather 함수가 직관적이지 않다면 그 대안으로 나온 pivot_longer를 사용하는 것도 방법입니다. 두 함수의 결과는 같으니까 원하는 것 사용하면 될 겁니다. tidyr 패키지 제작자인 해들리 위컴은 새로 나온 pivot_longer함수를 추천하고 있어요.\nlibrary(tidyr)\n\nPE_20_final <- PE_20_rate %>% gather(key = \"후보\", value = \"득표율\", 이재명R, 윤석열R, 심상정R)\n\n# key: long form 데이터로 바꾸었을 때 이름이 될 칼럼명\n# value: long form 데이터로 바꾸었을 때 값이 들어갈 칼럼명\n# PE_20_rate의 칼럼 중 후보별 득표율 칼럼 3개(이재명R, 윤석열R, 심상정R)를 써주면 됩니다.\n\n\nPE_20_final <- PE_20_rate %>% pivot_longer(cols = ends_with(\"R\"), \n                                           names_to = \"후보\",\n                                           values_to = \"득표율\")\n\n# cols: long form 데이터로 바꾸고 싶은 칼럼들(이재명R, 윤석열R, 심상정R)\n# ends_with: 동일한 단어로 끝나는 애들만 고를 때 사용하는 함수(tidyselect package의 함수)\n# names_to : long form 데이터로 바꾸었을 때 이R, 윤R, 심R이 들어갈 칼럼 이름\n# values_to : long form 데이터로 바꾸었을 때 value 값에 들어갈 칼럼 이름\n\n# A tibble: 6 × 5\n   code 구분       시군구명 후보    득표율\n  <dbl> <chr>      <chr>    <chr>    <dbl>\n1 11110 서울특별시 종로구   이재명R  0.464\n2 11140 서울특별시 중구     이재명R  0.454\n3 11170 서울특별시 용산구   이재명R  0.399\n4 11200 서울특별시 성동구   이재명R  0.432\n5 11215 서울특별시 광진구   이재명R  0.472\n6 11230 서울특별시 동대문구 이재명R  0.471\n# A tibble: 6 × 5\n   code 구분       시군구명 후보    득표율\n  <dbl> <chr>      <chr>    <chr>    <dbl>\n1 11110 서울특별시 종로구   이재명R 0.464 \n2 11110 서울특별시 종로구   윤석열R 0.495 \n3 11110 서울특별시 종로구   심상정R 0.0313\n4 11140 서울특별시 중구     이재명R 0.454 \n5 11140 서울특별시 중구     윤석열R 0.510 \n6 11140 서울특별시 중구     심상정R 0.0274\n\nggplot 그래프 그리기\n데이터도 정리가 되었겠다… 이제 이것을 가지고 그래프로 그려서 그리드에 넣으면 끝입니다. 일단 후보별 득표율을 가지고 지역별로 들어갈 바 차트가 어떤 모양이 될지, 샘플을 만들어보겠습니다. 서울특별시 종로구(code = 11110)를 가지고 예시로 그려봅시다.\nPE_20_final$후보 <- factor(PE_20_final$후보, levels = c(\"심상정R\", \"윤석열R\", \"이재명R\"))\n\ndata_11110 <- PE_20_final %>% filter(code == 11110)\n\nggplot(data_11110, aes(x = 후보, y = 득표율, fill = 후보)) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(values = c(\"#F7EF99\", \"#fc7b84\", \"#008EC6\")) +\n  theme_chichead()\n  \n# 그래프를 그렸을 때 기호순으로 나열될 수 있도록 factor level을 부여해줍니다.\n# coord_flip()를 사용하면 후보의 순서가 뒤집어지기때문에 factor level은 역순으로.\n# 각 후보에 맞춰서 컬러 팔레트 설정해줍니다.\n# 잡다구리한 요소들을 다 뺀 chichead만의 테마를 만들어 적용합니다.\n\n\n\n최종 시각화\n이제 이 그래프를 250개 시군구에 넣으면 됩니다. 어떻게? geofacet::facet_geo 함수를 쓰면 단 한 줄이면 만들 수 있습니다. 전국 지도에서 3위 후보의 득표율이 보이질 않으니… 일단 제외하고 1, 2위 후보만 시각화를 해 보겠습니다.\nlibrary(geofacet)\n\nggplot(subset(PE_20_final, 후보 != \"심상정R\"), aes(x = 후보, y = 득표율, fill = 후보)) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(values = c(\"#fc7b84\", \"#008EC6\")) +\n  facet_geo(~ code, grid = mygrid) +\n  theme_chichead() +\n  theme(\n    strip.background = element_blank(),\n    strip.text.x = element_blank(),\n    axis.text.y = element_blank()\n  ) + \n  scale_y_continuous(breaks = c(.5, 1), limits = c(0, 1))\n  \n# 위의 코드에서 추가된 건 facet_geo()뿐\n# 만들어 놓은 그리드(mygrid)와 join할 데이터(code)를 입력하면 끝\n# 시각화 정리는 theme에서 약간의 조정으로 마무리\n\n\n\n짜잔! 이러면 우리가 원했던 250개 시군구 그리드에 각각의 후보별 득표율을 그릴수 있게 되었습니다.\n\n\n\n",
    "preview": "https://raw.githubusercontent.com/chichead/chichead.github.io/master/_posts/geofacet_package/map.webp",
    "last_modified": "2022-03-20T22:58:52+09:00",
    "input_file": "geofacet_package.knit.md"
  },
  {
    "path": "posts/ggbump_package/",
    "title": "ggbump package",
    "description": "R아두면 쓸데있는 패키지 이야기 : bump chart를 그리고 싶을 땐",
    "author": [
      {
        "name": "chichead",
        "url": {}
      }
    ],
    "date": "2022-02-20",
    "categories": [
      "R_package"
    ],
    "contents": "\n\nContents\nggbump package\nggbump’s name\nbump chart\nggbump’s logo\n\nAll about ggbump\ngeom_sigmoid\ngeom_bump\n\n\nggbump package\nggbump’s name\nggplot2는 grammar of graphics(a.k.a. gg)을 토대로 시각화를 만드는 패키지입니다. 2는 ver.2의 의미를 담았죠. gg는 릴랜드 윌킨스의 동명의 책 The Grammar of Graphics에서 따온 건데, 이 책에서 릴랜드는 데이터를 어떻게 시각적으로 표현할 것인지에 대해 다룹니다. gg에 대한 이야기는 나중에 따로 하기로 하고…\nggplot2 패키지의 문법 기반 위에서 돌아가는 서브 패키지들은 보통 gg라는 접두사로 시작됩니다. ggbump 역시 ggplot2의 일원이라고 이해할 수 있어요. 그렇다면 bump는 무엇을 의미하는 걸까요? 자동차의 범퍼, 혹은 놀이동산의 범퍼카를 떠올리면 bump의 의미를 유추할 수 있어요. bump는 바로, 충돌을 의미합니다. 충돌과 차트, 어떤 연관이 있는 걸까요?\nbump chart\n영국의 케임브리지 대학에는 The bump라고 불리는 조정 경기가 있습니다. 케임브리지를 가로지르는 캠 강(river Cam) 은 나란히 경주하기에는 너무 좁아서 한 줄로 경주하는 독특한 조정 경주를 진행해왔어요. 19세기 초부터 시작된 이 경기 이름이 바로 The bump입니다. The bump의 경주 방식은 이렇습니다. 우선 강을 따라 한 줄로 경기를 시작합니다. 각 선수들은 전속력으로 노를 저어 앞에 있는 보트를 따라잡고 충돌(bump)하죠. 그렇게 되면 앞에 있는 조정 팀을 추월한 것으로 인정, 순위가 올라가게 됩니다. 주최 측에서는 경기의 진행 상황을 매핑하는 차트를 그려서 제공했는데, 이 차트를 bump chart라고 불렀습니다.\n아래 차트는 2020년 사순절에 치러진 대회(Lent Bump)의 남자부 경기 결과입니다. 어떤 차트인지 감이 오죠?\n\n\nggbump’s logo\n\n로고에는 3개의 노드(점), 노드에 연결된 시그모이드 곡선이 보입니다. 시그모이드(Sigmoid) 곡선은 S자 모양의 부드러운 곡선을 의미합니다. Sigmoid라는 단어의 뜻이 S자 모양이거든요. 시그모이드 곡선은 로지스틱 방정식, 정규분포의 누적분포함수에서 확인할 수 있습니다. 아래 차트를 보면 정규분포의 누적분포함수의 부드러운 S자 곡선을 확인할 수 있습니다.\n\n\n\n# ggplot2에서 주요 확률분포 곡선을 그릴 때는 stat_function을 활용하면 됩니다\n# 정규분포(norm)의 누적분포함수를 그릴 땐 fun = pnorm 조건을 쓰세요\n# 마찬가지로 지수분포(exp)에서 누적분포함수를 그릴 땐 fun = pexp 조건을 쓰면 됩니다.\n\nggplot(data.frame(X = c(-3, 3)), aes(x = X)) +\n  stat_function(fun = pnorm, colour = \"black\", size = 1) +\n  ggtitle(\"Cumulative Normal Distribution of X ~ N(0,1)\") +\n  theme_classic()\n\n# 참고로 접두사 p는 누적분포함수(CDF)를 의미하고, \n# 접두사 q는 누적분포함수(CDF)의 역함수인 분위수함수를, \n# 접두사 r은 무작위 난수 샘플을 의미합니다\nggbump package를 활용하면 시그모이드 곡선도 그릴 수 있습니다. 그럼 본격적으로 ggbump 패키지에 대해서 살펴보도록 하죠.\n\nAll about ggbump\ngeom_sigmoid\n\n  x  y xend yend\n1 1  5    7   -5\n2 2  6    7   -4\n3 3  7    7   -3\n4 4  8    7   -2\n5 5  9    7   -1\n6 6 10    7    0\n\n시그모이드 곡선에 필요한 변수는 시작점, 끝점, 그룹 정도입니다. 시작점의 위치는 (x, y) 변수에, 끝점의 위치는 (xend, yend) 변수에 넣으면 되죠. 그리고 어떤 점끼리 이어지는지 그룹을 결정해주면 됩니다. 위의 데이터를 가지고 시그모이드 곡선을 그려보면 총 6개의 선이 그려집니다. (1, 5)와 (7, -5)를 잇는 곡선을 포함해서 말이죠.\n\n\n\n# geom_sigmoid 함수에서 x, y, xend, yend, group 변수를 지정해주면 됩니다.\n# geom_sigmoid 외의 함수는 점(geom_point)과 라벨(geom_text)을 위한 함수입니다.\n\nggplot(df) +\n  geom_sigmoid(aes(x = x, xend = xend, y = y, yend = yend, group = factor(x)), color = \"black\") +\n  geom_point(aes(x = x, y = y)) +\n  geom_point(aes(x = xend, y = yend)) +\n  geom_text(aes(x = x, y = y, label = paste0(\"(\", x, \", \", y, \")\")),\n            vjust = 1.8, size = 3) +\n  geom_text(aes(x = xend, y = yend, label = paste0(\"(\", xend, \", \", yend, \")\")),\n            vjust = 1.4, size = 3) +\n  theme_classic()\n\ngeom_bump\nbump chart를 그리기 위해선 geom_bump 함수를 사용하면 됩니다. 간단하게 가상의 데이터를 만들어 보겠습니다. 대한민국을 포함해 총 5개 국가(Korea, Japan, China, Russia, India)의 임의 데이터입니다. 아래와 같이 나라명과 연도(2020, 2021, 2022), 그리고 임의의 value값이 포함돼있습니다.\n\n# A tibble: 6 × 3\n  country  year value\n  <chr>   <dbl> <dbl>\n1 Korea    2020   500\n2 Korea    2021   200\n3 Korea    2022   100\n4 Japan    2020   400\n5 Japan    2021   300\n6 Japan    2022   400\n\ngeom_bump 함수를 사용하려면 rank 값이 필요합니다. 각 연도별로 묶어서 value값에 따라 rank 값을 부여하면 되겠습니다. rank 함수를 사용하면 됩니다.\ndf <- df %>%\n  group_by(year) %>%\n  mutate(rank = rank(value, ties.method = \"random\")) %>%\n  ungroup()\n\n# ties.method는 만일 value값이 동등할경우 어떻게 계산할 것인지 결정하는 부분입니다.\n# 보통은 min(동률 순위 중 낮은 값 출력), max(동률 순위 중 높은 값 출력)을 사용합니다.\n# 여기선 그냥 겹치지 않게 그리기 위해 random method(순서 상관없이 랜덤)를 선택했습니다.\n\n# A tibble: 6 × 4\n  country  year value  rank\n  <chr>   <dbl> <dbl> <int>\n1 Korea    2020   500     5\n2 Korea    2021   200     1\n3 Korea    2022   100     2\n4 Japan    2020   400     3\n5 Japan    2021   300     2\n6 Japan    2022   400     5\n\nrank값이 잘 나왔군요. rank값은 값이 크면 클수록 더 높은 숫자가 부여됩니다. 2020년 한국의 value는 500, 일본의 value는 400인데 한국이 4위, 일본이 3위인 걸 보면 알 수 있죠. 우리가 보통 생각하는 순위와는 반대입니다. 위에서 rank를 계산할 때 -value로 계산한다면 이 부분은 해결할 수 있습니다. 여기선 그래프를 그릴 때 y축을 돌려버리는 걸로 처리하겠습니다.\nggplot(df, aes(year, rank, color = country)) +\n  geom_bump() +\n  theme_classic() +\n  theme(legend.position = \"none\") +\n  scale_y_reverse() +\n  scale_color_manual(values = wes_palette(\"Zissou1\", n = 5))\n\n\n\n부드러운 시그모이드 곡선으로 이뤄진 범프 차트가 만들어졌습니다. scale_color_manual에 들어있는 wes_palette는 이름에서 유추할 수 있듯 웨스 앤더슨 감독의 색감이 담긴 컬러 팔레트입니다. 이 차트에서는 웨스 앤더슨 감독의 2004년 작 <스티브 지소와의 해저 생활(The Life Aquatic With Steve Zissou)>의 색상을 사용했습니다.\n\n여기서 조금 더 꾸며볼까요? bump line의 폭을 늘리고 점도 찍어보고, 해당 라인이 어떤 국가를 의미하는지 라벨도 달아보겠습니다. 축은 있으면 보기 싫으니 선을 다 없애버립시다. 그리고 x축은 정수 연도만 남겨야 할 것 같고요. 정리해보면 이렇게 될 겁니다.\nggplot(df, aes(year, rank, color = country)) +\n  geom_bump(size = 5, smooth = 8, alpha = 0.8) +\n  geom_point(size = 5) +\n  geom_text(data = df %>% filter(year == min(year)),\n            aes(x = year, label = country), size = 5, hjust = 0, vjust = -1) +\n  geom_text(data = df %>% filter(year == max(year)),\n            aes(x = year, label = country), size = 5, hjust = 1, vjust = -1) +\n  theme_minimal() +\n  theme(legend.position = \"none\",\n        panel.grid.major = element_blank()) +\n  scale_x_continuous(limits = c(2019.95, 2022.05),\n                     breaks = seq(2020, 2022, 1)) +\n  scale_y_reverse(limits = c(5, 0.5)) +\n  labs(y = \"RANK\",\n       x = NULL) +\n  scale_color_manual(values = wes_palette(\"Zissou1\", n = 5))\n\n\n\n\n\n\n",
    "preview": "https://raw.githubusercontent.com/chichead/chichead.github.io/master/_posts/ggbump_package/zissou.gif",
    "last_modified": "2022-02-20T18:28:47+09:00",
    "input_file": "ggbump.knit.md"
  },
  {
    "path": "posts/tibble_package/",
    "title": "tibble package",
    "description": "R아두면 쓸데있는 패키지 이야기 : 데이터 테이블의 진화",
    "author": [
      {
        "name": "chichead",
        "url": {}
      }
    ],
    "date": "2021-05-02",
    "categories": [
      "R_package"
    ],
    "contents": "\n\nContents\ntibble package\ntibble’s name\ntibble’s logo\n\nAll about tibble\nas.tibble\ntibble\ntribble\ntibble_row\n\n\ntibble package\n\ntidyverse 패키지를 사용하면 data.frame 대신 사용하게되는 tibble. 오늘 알아볼 R package는 tibble입니다. tibble 패키지의 역사부터 기존의 data.frame과는 어떻게 다른지 정리해봅니다.\ntibble’s name\n2014년 1월, dplyr 패키지에선 data.frame을 tbl_df이라는 서브클래스로 사용했습니다. 이전의 data.frame과 다르게 출력된 결과가 콘솔창을 다 뒤덮지도 않고 칼럼명 아래에 자료형을 표현해주는 강점이 있었죠. 이 tbl_df가 지금의 tibble 패키지의 시초입니다. tbl_df를 [티블-디프]로 읽다가 뒤에 df는 떨어져나가고 tbl남 남아 결국엔 tibble이 되었죠. 참고로 패키지를 만든 해들리 위컴은 뉴질랜드 사람인데, 뉴질랜드인들이 table을 tibble이라고 발음한다고 합니다.\ntibble’s logo\n위대한 패키지 tidyverse의 일원인만큼 tibble 로고의 뒷 배경은 tidyverse 세계관을 공유하고 있습니다. 우주 배경을 뒤에 두고 표가 그려져있죠. 그 위엔 TIBBLE 이라는 이름표가 적혀있고요. 폰트 스타일은 스타트랙을 닮았는데, 스타트랙에는 tibble과 유사한 tribble이라는 크리쳐가 등장합니다. tribble은 tibble 패키지의 함수로도 등장하는데 이건 뒤에서 설명 드리겠습니다. tibble 이름표를 잘 보면 TI33으로도 읽을 수 있는데 공학용 계산기로 유명한 텍사스 인스트루먼트(TI)에서 만든 동명의 모델이 있죠. (물론 의도한지는 모르겠지만요)\n\nAll about tibble\nas.tibble\n아이리스(붓꽃) 데이터가 담겨있는 iris 데이터를 가지고 살펴보겠습니다. 총 150개의 로(row)와 5개의 칼럼(column)으로 이뤄진 데이터프레임(data.frame)입니다. 만일 코드에 그냥 iris라고 입력한다면 콘솔창에는 150개의 행을 보실 수 있을텐데요. 그걸 막기 위해 iris 데이터의 머릿부분만 불러오라는 함수 head( )를 써보았어요.\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n이번엔 tibble 패키지를 이용해볼까요. 여기서 사용할 함수는 as_tibble( )입니다. 무언가를 tibble로 만들어주는 고마운 함수입니다. 새로운 iris tibble 녀석을 tbl_iris에 할당했습니다. 그리고 불러와봅시다. tibble은 그냥 tbl_iris라고 입력해도 콘솔창을 다 뒤덮지않는군요. 10개의 행을 보여주고는 나머지 140개가 남아있다고 깨알같이 설명해줍니다. 게다가 5개의 칼럼이 어떤 녀석인지 밑에다가 자료형을 설명해주고 있군요. 착한 녀석이죠. 혹여나 이러한 편의를 무시하고 모든 행을 다 보고 싶은 경우에는 옵션을 통해 바꿔줄 수 있습니다.\nlibrary(tibble)\n\n# as_tibble(sth) : sth을 tibble로 만들어주세요\ntbl_iris <- as_tibble(iris)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# … with 140 more rows\n\n# 행이 n개를 넘어가면 m개만 출력해줘\n# options(tibble.print_max = n, tibble.print_min = m)\n\n# 모든 행을 다 보여줘\n# option(tibble.print_max = Inf)\n\n# 콘솔창의 폭은 고려말고 모든 열을 다 보여줘\n# option(tibble.width = Inf)\n\ntibble\n본격적으로 tibble을 만들어봅니다. tibble( )을 이용하면 후딱 tibble을 생성할 수 있답니다. tibble( ) 함수는 data.frame( ) 함수와는 다르게 변수의 이름을 바꾸지 않아요. 예를 들어볼게요. 닭 대가리라는 칼럼에 숫자 1을 넣은 data.frame을 만들어볼거에요. 동일하게 tibble로도 만들어보고요.\n# 닭 대가리라는 칼럼을 가진 데이터를 만들어봅니다\ndata.frame(`닭 대가리` = 1)\ntibble(`닭 대가리` = 1)\n\n  닭.대가리\n1         1\n# A tibble: 1 × 1\n  `닭 대가리`\n        <dbl>\n1           1\n\n칼럼 이름에 공백이 들어가게 되면 data.frame은 공백을 온점으로 바꿔줍니다. 닭 대가리 대신 닭.대가리가 되었죠? 반면 tibble은 변수의 이름을 바꾸지 않고 그대로 내비두죠. 이러한 tibble의 유연함은 공백말고 다른 비정상적인 문자도 칼럼 이름에 넣을 수 있게했어요.\n# tibble은 비정상적 문자도 칼럼명에 넣을 수 있답니다\n# 아 물론 백틱(`)으로 묶어주어야해요!\ntb <- tibble(\n  `:^)` = \"smile\", \n  ` ` = \"space\",\n  `2021` = \"number\"\n)\n\n# A tibble: 1 × 3\n  `:^)` ` `   `2021`\n  <chr> <chr> <chr> \n1 smile space number\n\n\ntribble\n\ntibble을 만들 수 있는 또다른 방법은 함수 tribble을 사용하는겁니다. 스타 트렉의 커크 함장에게 눈처럼 내리는 동물이 바로 트리블이랍니다. 트리블은 복실복실한 털과 귀여운 목소리 탓에 애완용으로 많이 키워졌는데 다만 한가지 주의해야할 부분은 바로 번식이랍니다. 한 번 번식을 시작하면 끝도 없이 증식해버려서 자칫하면 손을 쓸 수 없을지도 몰라요.\ntibble 패키지에 있는 tribble은 transposed tibble의 줄임말입니다. 단어 그대로 전치된 티블이라는 뜻이지요. 기존의 tibble 입력 형식이 colname = data 같은 가로형이었다면 tribble에서는 세로형으로 입력할 수 있지요. 간단하게 적은 양의 데이터를 코드로 입력할 때에는 tribble을 쓰면 편리합니다.\n# tribble 함수에서 칼럼명은 ~로 시작해주셔야해요\n# 데이터 구분은 ,로 해주시고요\ntribble(\n  ~x, ~y, ~z,\n  \"a\", 21, \"2000\",\n  \"b\", 31, \"1990\"\n)\n\n# A tibble: 2 × 3\n  x         y z    \n  <chr> <dbl> <chr>\n1 a        21 2000 \n2 b        31 1990 \n\n\ntibble_row\ntibble을 만들 수 있는 또 다른 방법. tibble_row( )가 있어요. 기본적으로 data.frame과 tibble은 벡터들의 모음입니다. 여기서 잠깐, 벡터는 동일한 유형의 데이터가 여러개 묶여있는 형식을 뜻해요. 수치형 벡터도 있을 테고, 문자형 벡터도 있을 거고요, 논리형 벡터도 존재해요. 함수 등과 같이 특별한 타입의 데이터들은 벡터가 아니여요. class를 가지고 있는 일부 요소들은 벡터이기도 하고 아닌 녀석도 있죠.\ntibble_row 이야기를 하는데 갑자기 벡터 이야기를 해서 뜬금없다고 생각할 수 있지만 다 이유가 있답니다. 기존 함수들로는 벡터가 아닌 데이터(스칼라)를 tibble 안에 담을 수 없었어요. 하지만 tibble_row 함수와 함께라면 스칼라도 tibble 안에 넣을 수 있게 되죠. tibble_row 함수는 한 행(row)을 차지하는 데이터프레임을 구성해줍니다. 즉 한 열에 크기가 1인 녀석만 들어갈 수 있지만 그 대신 스칼라 데이터도 넣을 수 있게 된 거죠. 참고로 저장되는 스칼라는 list 형태로 포장됩니다.\n# vector가 아닌 scalar 데이터를 만들어봅니다\n# lm(linear model)과 time 데이터를 써 볼게요\n\nmodel <- lm(y ~ x, data.frame(x = 1:5, y = 3:7), model = FALSE)\ntime <- Sys.time()\n\ntibble(model)\n\n# 에러: All columns in a tibble must be vectors.\n# x Column `model` is a `lm` object.\n\ntibble(time)\n\n#  A tibble: 1 x 1\n#  time               \n#  <dttm>             \n# 1 2021-05-06 23:41:31\nmodel의 경우 vector가 아니여서 tibble에 담기지 않아요. 반면 time 데이터는 들어가네요. 하지만 tibble_row 함수가 출동한다면 어떨까요. tibble_row와 함께라면 vector와 scalar 상관없이 tibble에 담을 수 있어요.\ntibble_row(model)\n\n#  A tibble: 1 x 1\n#  model \n#  <list>\n# 1 <lm>  \n\ntibble_row(time)\n#  A tibble: 1 x 1\n#  time               \n#  <dttm>             \n# 1 2021-05-06 23:41:31\n\n\n\n",
    "preview": "https://i.gifer.com/PFYe.gif",
    "last_modified": "2022-02-20T19:13:18+09:00",
    "input_file": "tibble_package.knit.md"
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to My Blog",
    "description": "Welcome to our new blog, My Blog. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2021-04-23",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-08T19:42:43+09:00",
    "input_file": {}
  }
]
